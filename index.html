<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Aircraft Game</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
        display: flex;
        justify-content: center;
        align-items: center;
        background: black;
        height: 100vh;
        overflow: hidden;
    }
    #gameContainer {
        position: relative;
        aspect-ratio: 4 / 3;
        width: 100vw;
        max-height: 100vh;
        background: url('assets/background.png') repeat-y center/cover;
        overflow: hidden;
    }
    #player {
        position: absolute;
        width: 60px;
        height: 60px;
        background: url('assets/player.png') no-repeat center/contain;
        bottom: 10%;
        left: 50%;
        transform: translateX(-50%);
    }
    .enemy, .boss, .bullet, .enemyBullet, .power {
        position: absolute;
        background-size: contain;
        background-repeat: no-repeat;
    }
    .enemy { width: 50px; height: 50px; background-image: url('assets/enemy.png'); }
    .boss { width: 120px; height: 120px; background-image: url('assets/boss.png'); }
    .bullet { width: 8px; height: 20px; background-image: url('assets/bullet_green.png'); }
    .enemyBullet { width: 8px; height: 20px; background-image: url('assets/bullet_red.png'); }
    .power { width: 35px; height: 35px; }
    #hud {
        position: absolute;
        top: 5px; left: 10px;
        color: white;
        font-family: sans-serif;
        font-size: 18px;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    #hearts img { width: 25px; height: 25px; }
</style>
</head>
<body>
    <div id="gameContainer">
        <div id="player"></div>
        <div id="hud">
            <div id="score">Score: 0</div>
            <div id="hearts"></div>
        </div>
    </div>

<script>
const container = document.getElementById("gameContainer");
const player = document.getElementById("player");
const scoreDisplay = document.getElementById("score");
const heartsDisplay = document.getElementById("hearts");

const bgMusic = new Audio("sounds/bgm.mpeg");
bgMusic.loop = true;
bgMusic.volume = 0.5;
bgMusic.play().catch(()=>{});

let score = 0;
let lives = 3;
let playerX = container.clientWidth / 2 - 30;
let playerY = container.clientHeight * 0.9 - 30;
let bullets = [], enemies = [], enemyBullets = [], powers = [], bosses = [];
let gameInterval, enemySpawnInterval, enemyFireInterval, powerSpawnInterval, bossInterval;
let isDoubleFire = false;

function updateHearts() {
    heartsDisplay.innerHTML = "";
    for (let i = 0; i < lives; i++) {
        const img = document.createElement("img");
        img.src = "assets/heart.png";
        heartsDisplay.appendChild(img);
    }
}
updateHearts();

function spawnEnemy() {
    const enemy = document.createElement("div");
    enemy.classList.add("enemy");
    enemy.style.left = Math.random() * (container.clientWidth - 50) + "px";
    enemy.style.top = "-60px";
    container.appendChild(enemy);
    enemies.push({el: enemy, hits: 0});
}

function spawnPower() {
    const types = ["power_double_fire", "power_shield", "power_extra_life"];
    const type = types[Math.floor(Math.random() * types.length)];
    const power = document.createElement("div");
    power.classList.add("power");
    power.style.backgroundImage = `url('assets/${type}.png')`;
    power.dataset.type = type;
    power.style.left = Math.random() * (container.clientWidth - 40) + "px";
    power.style.top = "-50px";
    container.appendChild(power);
    powers.push(power);
}

function spawnBoss() {
    const boss = document.createElement("div");
    boss.classList.add("boss");
    boss.style.left = Math.random() * (container.clientWidth - 120) + "px";
    boss.style.top = "-150px";
    boss.dataset.health = 40;
    container.appendChild(boss);
    bosses.push(boss);
}

function shoot() {
    const bullet = document.createElement("div");
    bullet.classList.add("bullet");
    bullet.style.left = player.offsetLeft + player.offsetWidth/2 - 4 + "px";
    bullet.style.top = player.offsetTop - 20 + "px";
    container.appendChild(bullet);
    bullets.push(bullet);
}

setInterval(()=> shoot(), 200); // fast fire rate

function enemyFire() {
    enemies.forEach(e=>{
        const bullet = document.createElement("div");
        bullet.classList.add("enemyBullet");
        bullet.style.left = e.el.offsetLeft + 20 + "px";
        bullet.style.top = e.el.offsetTop + 40 + "px";
        container.appendChild(bullet);
        enemyBullets.push(bullet);
    });
}

function update() {
    // background move
    container.style.backgroundPositionY = (parseFloat(container.style.backgroundPositionY) || 0) + 2 + "px";

    // bullets move
    bullets.forEach((b, i) => {
        b.style.top = b.offsetTop - 8 + "px";
        if (b.offsetTop < -20) { b.remove(); bullets.splice(i,1); }
    });

    // enemies move
    enemies.forEach((e, i) => {
        e.el.style.top = e.el.offsetTop + 2 + "px";
        if (e.el.offsetTop > container.clientHeight) {
            e.el.remove(); enemies.splice(i,1);
        }
    });

    // powers move
    powers.forEach((p, i)=>{
        p.style.top = p.offsetTop + 2 + "px";
        if (p.offsetTop > container.clientHeight) { p.remove(); powers.splice(i,1); }
    });

    // boss move
    bosses.forEach((b, i)=>{
        b.style.top = b.offsetTop + 1 + "px";
        if (b.offsetTop > 100) b.style.top = "100px";
    });

    // enemy bullets move
    enemyBullets.forEach((b,i)=>{
        b.style.top = b.offsetTop + 4 + "px";
        if (b.offsetTop > container.clientHeight) { b.remove(); enemyBullets.splice(i,1); }
    });

    // collisions
    bullets.forEach((b, bi)=>{
        enemies.forEach((e, ei)=>{
            if (isColliding(b, e.el)) {
                e.hits++;
                b.remove(); bullets.splice(bi,1);
                if (e.hits >= 3) {
                    score += 10;
                    scoreDisplay.textContent = "Score: " + score;
                    e.el.remove(); enemies.splice(ei,1);
                    if (score % 200 === 0) spawnBoss();
                }
            }
        });
        bosses.forEach((boss, bi2)=>{
            if (isColliding(b, boss)) {
                let hp = boss.dataset.health - 1;
                boss.dataset.health = hp;
                b.remove(); bullets.splice(bi,1);
                if (hp <= 0) {
                    score += 100;
                    scoreDisplay.textContent = "Score: " + score;
                    boss.remove(); bosses.splice(bi2,1);
                }
            }
        });
    });

    // player collision with power
    powers.forEach((p, i)=>{
        if (isColliding(p, player)) {
            const type = p.dataset.type;
            if (type === "power_extra_life" && lives < 3) lives++;
            if (type === "power_double_fire") isDoubleFire = true;
            if (type === "power_shield") player.style.opacity = "0.5";
            updateHearts();
            p.remove(); powers.splice(i,1);
        }
    });

    // enemy bullets hit player
    enemyBullets.forEach((b,i)=>{
        if (isColliding(b, player)) {
            b.remove(); enemyBullets.splice(i,1);
            if (player.style.opacity === "0.5") return; // shield active
            lives--;
            updateHearts();
            if (lives <= 0) gameOver();
        }
    });
}

function isColliding(a,b){
    const ar = a.getBoundingClientRect(), br = b.getBoundingClientRect();
    return !(ar.right < br.left || ar.left > br.right || ar.bottom < br.top || ar.top > br.bottom);
}

function gameOver(){
    clearInterval(gameInterval);
    clearInterval(enemySpawnInterval);
    clearInterval(enemyFireInterval);
    clearInterval(powerSpawnInterval);
    alert("Game Over! Final Score: "+score);
    location.reload();
}

enemySpawnInterval = setInterval(spawnEnemy, 2600);
enemyFireInterval = setInterval(enemyFire, 2000);
powerSpawnInterval = setInterval(spawnPower, 2000);
gameInterval = setInterval(update, 30);

// swipe + drag controls
let startX = null;
container.addEventListener("touchstart", e=>{
    startX = e.touches[0].clientX;
});
container.addEventListener("touchmove", e=>{
    if (startX === null) return;
    let deltaX = e.touches[0].clientX - startX;
    playerX += deltaX;
    if (playerX < 0) playerX = 0;
    if (playerX > container.clientWidth - player.offsetWidth) playerX = container.clientWidth - player.offsetWidth;
    player.style.left = playerX + "px";
    startX = e.touches[0].clientX;
});
container.addEventListener("touchend", ()=> startX = null);
</script>
</body>
</html>
