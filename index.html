<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Aircraft Game</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: black;
    touch-action: none;
  }
  canvas {
    display: block;
    background: url("assets/background.png") repeat-y center/cover;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<audio id="bgm" src="sounds/bgm.mpeg" loop></audio>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = innerWidth;
canvas.height = innerHeight;

// Load images
const load = (src) => { const i = new Image(); i.src = src; return i; };
const background = load("assets/background.png");
const playerImg = load("assets/player.png");
const enemyImg = load("assets/enemy.png");
const bossImg = load("assets/boss.png");
const bulletGreen = load("assets/bullet_green.png");
const bulletRed = load("assets/bullet_red.png");
const powerDouble = load("assets/power_double_fire.png");
const powerShield = load("assets/power_shield.png");
const powerLife = load("assets/power_extra_life.png");
const heartImg = load("assets/heart.png");

const bgm = document.getElementById("bgm");
bgm.play().catch(() => {
  document.body.addEventListener("click", () => bgm.play(), { once: true });
});

let bgY = 0, score = 0;
let lives = 3;
let doubleFire = false, shield = false;
let enemies = [], bullets = [], enemyBullets = [], power = null, boss = null, bossBullets = [];

const player = {
  x: canvas.width / 2 - 40,
  y: canvas.height - 150,
  width: 80,
  height: 80,
};

// ðŸ”« Player fires every 0.2s
setInterval(() => {
  if (doubleFire) {
    bullets.push({ x: player.x + 10, y: player.y, width: 15, height: 30 });
    bullets.push({ x: player.x + player.width - 25, y: player.y, width: 15, height: 30 });
  } else {
    bullets.push({ x: player.x + player.width / 2 - 8, y: player.y, width: 15, height: 30 });
  }
}, 200);

// ðŸ‘¾ Enemies spawn every 2.6s
setInterval(() => {
  enemies.push({ x: Math.random() * (canvas.width - 60), y: -60, width: 60, height: 60, hp: 3 });
}, 1500);

// ðŸ’£ Enemies fire every 2s
setInterval(() => {
  enemies.forEach(e => {
    enemyBullets.push({ x: e.x + e.width / 2 - 5, y: e.y + e.height, width: 10, height: 20 });
  });
}, 1000);

// âš¡ Powers every 2s
setInterval(() => {
  if (!power) {
    const types = ["double", "shield", "life"];
    const t = types[Math.floor(Math.random() * types.length)];
    power = { type: t, x: Math.random() * (canvas.width - 50), y: -50, width: 50, height: 50 };
  }
}, 2000);

// ðŸ‘¹ Boss spawn every 200 points
function spawnBoss() {
  if (!boss && score >= 200 && score % 200 === 0) {
    boss = { x: canvas.width / 2 - 100, y: 60, width: 200, height: 200, hp: 40 };
  }
}

// Boss fire every 1.5s (3 lanes)
setInterval(() => {
  if (boss) {
    for (let i = -1; i <= 1; i++) {
      bossBullets.push({
        x: boss.x + boss.width / 2 + i * 40,
        y: boss.y + boss.height,
        width: 15,
        height: 25
      });
    }
  }
}, 800);

// Swipe + drag control
let startX = null, dragging = false;
canvas.addEventListener("touchstart", e => { startX = e.touches[0].clientX; });
canvas.addEventListener("touchmove", e => {
  const x = e.touches[0].clientX;
  const dx = x - startX;
  player.x += dx;
  if (player.x < 0) player.x = 0;
  if (player.x > canvas.width - player.width) player.x = canvas.width - player.width;
  startX = x;
});
canvas.addEventListener("mousedown", e => { dragging = true; startX = e.clientX; });
canvas.addEventListener("mousemove", e => {
  if (dragging) {
    const dx = e.clientX - startX;
    player.x += dx;
    if (player.x < 0) player.x = 0;
    if (player.x > canvas.width - player.width) player.x = canvas.width - player.width;
    startX = e.clientX;
  }
});
canvas.addEventListener("mouseup", () => dragging = false);
canvas.addEventListener("mouseleave", () => dragging = false);

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Background
  bgY += 2;
  if (bgY >= canvas.height) bgY = 0;
  ctx.drawImage(background, 0, bgY - canvas.height, canvas.width, canvas.height);
  ctx.drawImage(background, 0, bgY, canvas.width, canvas.height);

  // Player
  ctx.drawImage(playerImg, player.x, player.y, player.width, player.height);

  // Bullets
  bullets.forEach((b, i) => {
    b.y -= 12;
    ctx.drawImage(bulletGreen, b.x, b.y, b.width, b.height);
    if (b.y < 0) bullets.splice(i, 1);
  });

  // Enemies
  enemies.forEach((e, ei) => {
    e.y += 3;
    ctx.drawImage(enemyImg, e.x, e.y, e.width, e.height);
    if (e.y > canvas.height) enemies.splice(ei, 1);

    bullets.forEach((b, bi) => {
      if (b.x < e.x + e.width && b.x + b.width > e.x && b.y < e.y + e.height && b.y + b.height > e.y) {
        e.hp--;
        bullets.splice(bi, 1);
        if (e.hp <= 0) {
          enemies.splice(ei, 1);
          score += 10;
          spawnBoss();
        }
      }
    });
  });

  // Enemy bullets
  enemyBullets.forEach((eb, ei) => {
    eb.y += 7;
    ctx.drawImage(bulletRed, eb.x, eb.y, eb.width, eb.height);
    if (eb.y > canvas.height) enemyBullets.splice(ei, 1);
    if (eb.x < player.x + player.width && eb.x + eb.width > player.x &&
        eb.y < player.y + player.height && eb.y + eb.height > player.y) {
      if (!shield) {
        lives--;
        enemyBullets.splice(ei, 1);
        if (lives <= 0) alert("Game Over! Refresh to restart.");
      } else {
        enemyBullets.splice(ei, 1);
      }
    }
  });

  // Powers
  if (power) {
    power.y += 3;
    let img = powerDouble;
    if (power.type === "shield") img = powerShield;
    if (power.type === "life") img = powerLife;
    ctx.drawImage(img, power.x, power.y, power.width, power.height);

    if (power.y > canvas.height) power = null;
    if (player.x < power.x + power.width && player.x + player.width > power.x &&
        player.y < power.y + power.height && player.y + player.height > power.y) {
      if (power.type === "double") doubleFire = true;
      if (power.type === "shield") shield = true;
      if (power.type === "life" && lives < 3) lives++;
      power = null;
    }
  }

  // Boss
  if (boss) {
    ctx.drawImage(bossImg, boss.x, boss.y, boss.width, boss.height);

    // Boss move slightly side to side
    boss.x += Math.sin(Date.now() / 500) * 2;

    // Boss bullets
    bossBullets.forEach((bb, bi) => {
      bb.y += 8;
      ctx.drawImage(bulletRed, bb.x, bb.y, bb.width, bb.height);
      if (bb.y > canvas.height) bossBullets.splice(bi, 1);
      if (bb.x < player.x + player.width && bb.x + bb.width > player.x &&
          bb.y < player.y + player.height && bb.y + bb.height > player.y) {
        if (!shield) {
          lives--;
          bossBullets.splice(bi, 1);
          if (lives <= 0) alert("Game Over! Refresh to restart.");
        } else {
          bossBullets.splice(bi, 1);
        }
      }
    });

    // Damage boss
    bullets.forEach((b, bi) => {
      if (b.x < boss.x + boss.width && b.x + b.width > boss.x && b.y < boss.y + boss.height && b.y + b.height > boss.y) {
        boss.hp--;
        bullets.splice(bi, 1);
        if (boss.hp <= 0) {
          score += 200;
          boss = null;
        }
      }
    });
  }

  // Score + Hearts
  ctx.font = "20px Arial";
  ctx.fillStyle = "white";
  ctx.fillText("Score: " + score, 20, 30);
  for (let i = 0; i < lives; i++) {
    ctx.drawImage(heartImg, 20 + i * 35, 40, 30, 30);
  }

  requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>

